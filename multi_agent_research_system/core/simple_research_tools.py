"""Simplified research tools that coordinate with built-in Claude tools.

This module provides minimal coordination tools while letting agents use
the built-in WebSearch and WebFetch capabilities directly.
"""

import json
import os

# Import from parent directory structure
import sys
import uuid
from datetime import datetime
from pathlib import Path
from typing import Any, Optional

sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))

# Load environment variables from .env file
try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    print("Warning: python-dotenv not found. Using environment variables only.")

# Import logging when available
try:
    from .logging_config import get_logger
    _logger = get_logger("research_tools")
    _logger.debug("Research tools logging initialized")
except ImportError:
    _logger = None

try:
    from claude_agent_sdk import tool
except ImportError:
    # Fallback decorator for when the SDK is not available
    def tool(name, description, parameters):
        def decorator(func):
            return func
        return decorator
    print("Warning: claude_agent_sdk not found. Using fallback tool decorator.")


@tool("save_research_findings", "Save research findings to session storage", {
    "topic": str,
    "findings": str,
    "sources": str,
    "session_id": str
})
async def save_research_findings(args: dict[str, Any]) -> dict[str, Any]:
    """Save research findings by returning data for external file creation."""
    if _logger:
        _logger.info(f"Preparing research findings for topic: {args.get('topic', 'Unknown')}")

    # Validate required arguments
    try:
        topic = args["topic"]
        findings = args["findings"]
        sources = args["sources"]
        session_id = args.get("session_id", str(uuid.uuid4()))
    except KeyError as e:
        error_msg = f"Missing required argument: {e}"
        return {"error": error_msg, "success": False}

    # Prepare research data structure
    research_data = {
        "topic": topic,
        "findings": findings,
        "sources": sources,
        "saved_at": datetime.now().isoformat(),
        "session_id": session_id
    }

    # Prepare file paths for external creation
    session_path = f"researchmaterials/sessions/{session_id}"
    findings_file = f"{session_path}/research_findings.json"

    kevin_dir = "/home/kjdragan/lrepos/claude-agent-sdk-python/KEVIN"
    timestamp = datetime.now().strftime('%H%M%S')
    kevin_findings_file = f"{kevin_dir}/research_findings_{session_id[:8]}_{timestamp}.json"

    if _logger:
        _logger.info(f"Research findings prepared for {topic} ({len(findings)} characters)")

    # Return data and file paths for external file creation
    return {
        "content": [{
            "type": "text",
            "text": f"Research findings for '{topic}' prepared for file creation. Session {session_id}, {len(findings)} characters of research content."
        }],
        "research_data": research_data,
        "session_file_path": findings_file,
        "kevin_file_path": kevin_findings_file,
        "session_id": session_id,
        "success": True
    }


@tool("create_research_report", "Create formatted report content and provide the filepath where it should be saved", {
    "topic": str,
    "content": str,
    "session_id": str,
    "format": str,
    "report_type": str  # e.g., "draft", "final", "editorial_review", "editorial_feedback"
})
async def create_research_report(args: dict[str, Any]) -> dict[str, Any]:
    """Create formatted report content and return it with the recommended filepath.

    NOTE: MCP tools cannot save files directly due to sandboxing. This tool formats the report
    and returns the content along with the recommended filepath. The agent MUST then use the
    Write tool to save the content to the recommended filepath.
    """
    if _logger:
        _logger.info(f"Creating research report for topic: {args.get('topic', 'Unknown')}")

    topic = args["topic"]
    content = args["content"]
    session_id = args.get("session_id", str(uuid.uuid4()))
    format_type = args.get("format", "markdown")
    report_type = args.get("report_type", "report")  # draft, final, editorial_review, etc.

    # Create formatted report content
    report_content = f"""# Research Report: {topic}

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Session ID:** {session_id}
**Report Type:** {report_type}

---

{content}

---

*This report was generated by the Multi-Agent Research System using Claude Agent SDK.*
"""

    # Determine the correct subdirectory based on report type
    if "editorial" in report_type.lower() or "review" in report_type.lower() or "feedback" in report_type.lower():
        subdir = "working"  # Editorial reviews and feedback go to working directory
    elif report_type.lower() == "final":
        subdir = "final"  # Final reports go to final directory
    else:
        subdir = "working"  # Drafts and other reports go to working directory

    # Generate filename with sanitized topic
    sanitized_topic = topic.replace(' ', '_').replace('/', '_')[:50]  # Limit length
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    extension = "md" if format_type == "markdown" else "txt"

    # Include report type in filename for clarity with prefixes for better organization
    # Format: PREFIX_reporttype_topic_timestamp.ext
    prefixes = {
        "draft": "DRAFT",
        "final": "FINAL",
        "editorial_review": "EDITORIAL",
        "editorial_feedback": "EDITORIAL_FEEDBACK",
        "research_findings": "RESEARCH",
        "search_verification": "SEARCH_VERIFY"
    }
    prefix = prefixes.get(report_type.lower(), report_type.upper())
    filename = f"{prefix}_{report_type}_{sanitized_topic}_{timestamp}.{extension}"
    # Use absolute path to ensure agents save files to correct location
    from pathlib import Path
    recommended_filepath = str(Path.cwd() / f"KEVIN/sessions/{session_id}/{subdir}/{filename}")

    # For final reports, also provide work_products path
    work_products_filepath = None
    if report_type.lower() == "final":
        work_products_filepath = str(Path.cwd() / f"KEVIN/work_products/reports/{filename}")

    if _logger:
        _logger.info(f"Research report formatted for {topic} ({len(report_content)} characters)")

    # Return instructions for the agent to save the file
    instruction_text = f"""Report content created for '{topic}' ({len(report_content)} characters).

⚠️  CRITICAL: You MUST now save this report using the Write tool.

Use this EXACT filepath:
    {recommended_filepath}

The Write tool will automatically create any necessary directories."""

    # For final reports, also create an accessible copy in working directory as fallback
    if report_type.lower() == "final":
        working_copy = str(Path.cwd() / f"KEVIN/sessions/{session_id}/working/{filename}")
        instruction_text += f"""

IMPORTANT: Also save a FINAL copy in working directory as fallback:
    {working_copy}

This ensures the final report is accessible even if finalization fails."""

    if work_products_filepath:
        instruction_text += f"""

Also save a copy for easy access at:
    {work_products_filepath}"""

    return {
        "content": [{
            "type": "text",
            "text": instruction_text
        }],
        "report_content": report_content,
        "recommended_filepath": recommended_filepath,
        "work_products_filepath": work_products_filepath,
        "session_id": session_id,
        "report_size": len(report_content),
        "report_type": report_type,
        "success": True
    }


@tool("get_session_data", "Retrieve data from a research session", {
    "session_id": str,
    "data_type": str
})
async def get_session_data(args: dict[str, Any]) -> dict[str, Any]:
    """Retrieve data from a research session."""
    session_id = args["session_id"]
    data_type = args.get("data_type", "all")

    # Try KEVIN directory structure first (primary)
    kevin_base = os.environ.get('KEVIN_WORKPRODUCTS_DIR', '/home/kjdragan/lrepos/claude-agent-sdk-python/KEVIN')
    session_path = Path(f"{kevin_base}/sessions/{session_id}")

    # Fallback to legacy researchmaterials structure
    if not session_path.exists():
        session_path = Path(f"researchmaterials/sessions/{session_id}")

    if not session_path.exists():
        return {
            "content": [{
                "type": "text",
                "text": f"Session {session_id} not found in KEVIN or researchmaterials directories."
            }]
        }

    result_data = {}

    # Try to load research findings (new standardized format)
    if data_type in ["all", "findings"]:
        findings_file = session_path / "research_findings.json"
        if findings_file.exists():
            with open(findings_file, 'r', encoding='utf-8') as f:
                findings_data = json.load(f)
                result_data["findings"] = findings_data

                # For backward compatibility, also provide structured data for report agents
                if "sources" in findings_data and "findings" in findings_data:
                    # This is the new standardized format
                    result_data["standardized_research"] = {
                        "research_topic": findings_data.get("research_topic"),
                        "research_timestamp": findings_data.get("research_timestamp"),
                        "sources": findings_data.get("sources", []),
                        "findings": findings_data.get("findings", []),
                        "key_themes": findings_data.get("key_themes", []),
                        "content_summary": findings_data.get("content_summary", ""),
                        "search_metrics": findings_data.get("search_metrics", []),
                        "source_analysis": findings_data.get("source_analysis", {}),
                        "quality_assessment": findings_data.get("quality_assessment", {}),
                        "research_metadata": findings_data.get("research_metadata", {})
                    }

    # Try to load research report
    if data_type in ["all", "report"]:
        report_files = list(session_path.glob("research_report.*"))
        if report_files:
            report_file = report_files[0]
            with open(report_file, 'r', encoding='utf-8') as f:
                result_data["report"] = f.read()

    # Try to load session state
    if data_type in ["all", "state"]:
        state_file = session_path / "session_state.json"
        if state_file.exists():
            with open(state_file, 'r', encoding='utf-8') as f:
                result_data["state"] = json.load(f)

    return {
        "content": [{
            "type": "text",
            "text": f"Retrieved {list(result_data.keys())} data types for session {session_id}"
        }],
        "session_data": result_data
    }